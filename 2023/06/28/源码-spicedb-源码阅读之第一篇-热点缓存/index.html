<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="[源码]spicedb: 源码阅读之第一篇(热点缓存)"><meta name="keywords" content="授权,零信任"><meta name="author" content="kylinlin"><meta name="copyright" content="kylinlin"><title>[源码]spicedb: 源码阅读之第一篇(热点缓存) | LGH's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"T9AYTHXI0G","apiKey":"c8176dfdf4a8e321983376969a20331c","indexName":"hexo","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.2'
} </script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="LGH's Blog" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Hotspot-Caching"><span class="toc-number">1.</span> <span class="toc-text">Hotspot Caching</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Cache-Entry"><span class="toc-number">2.</span> <span class="toc-text">Cache Entry</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gRPC-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">3.</span> <span class="toc-text">gRPC 负载均衡</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpiceDB-%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">4.</span> <span class="toc-text">SpiceDB 的负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-Resolver"><span class="toc-number">4.1.</span> <span class="toc-text">自定义 Resolver</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-Balancer"><span class="toc-number">4.2.</span> <span class="toc-text">自定义 Balancer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Others"><span class="toc-number">6.</span> <span class="toc-text">Others</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference"><span class="toc-number">7.</span> <span class="toc-text">Reference</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars.githubusercontent.com/u/6293256?s=180&amp;v=180"></div><div class="author-info__name text-center">kylinlin</div><div class="author-info__description text-center">email: kylinlingh@foxmail.com</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">6</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">9</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">4</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2019/12/20/kXR6KLoOcwDsUQy.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">LGH's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/aboutme">关于我</a><a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">[源码]spicedb: 源码阅读之第一篇(热点缓存)</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-06-28</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">源码阅读</a><div class="post-meta-wordcount"><i class="fa fa-sort-numeric-asc"></i><span> 字数总计: </span><span class="word-count">4.1k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o"></i><span> 阅读时长: 17 分钟</span><span class="post-meta__separator">|</span><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span> 阅读次数:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="Hotspot-Caching"><a href="#Hotspot-Caching" class="headerlink" title="Hotspot Caching"></a>Hotspot Caching</h1><p>由于 2/8 原则的存在，笼统来说，系统中百分之二十的数据占据了全部访问流量的百分之八十（其实还有更极端的 1/99 现象，百分之一的数据占据了流量的百分之九十九），因此热点数据的处理技术一直都是低时延和高可用系统的前沿研究对象，而 Hotspot caching（热点缓存）就是专门用于降低热点数据被高频访问时的延迟。</p>
<p>SpiceDB 处理热点数据的方法主要由两部分组成：</p>
<ul>
<li>在 node 上使用本地缓存将查询结果保存起来，但每个 node 都只缓存了在本 node 上计算的结果（也就是说不会对不同的 node 同步缓存数据）</li>
<li>使用一致性哈希算法，请求到达时先查询本地缓存，查询失败后会根据请求体的参数计算哈希值，然后往对应的 node 发送请求，一致性哈希算法的原理参考Reference 里的<a href="#refer-anchor"><sup>[1][2][3]</sup></a>。此处简单描述一下原理：<img src="https://uploads.toptal.io/blog/image/122756/toptal-blog-image-1492519276035-d42459e7afcbed4a7ccb88d45b3d750b.jpg" width="50%" height="50%" align=center></li>
</ul>
<p>在上图中，要缓存的值为白色节点，将这些要散列的值映射到一个圆环上（计算哈希值，然后将哈希值与圆环本身的角度做关联），然后加入三个服务器节点（A/B/C：同样计算三个服务器节点的哈希值并与圆环本身的角度做关联），此时定义一个规则将两者关联起来：每个 key 分配到逆时针方向（或顺时针）上离它最近的服务器，由此得到了下面的映射关系：<br><img src="https://hexo-pic-1300331708.cos.ap-guangzhou.myqcloud.com/2023-07-18-10-42-57.png"></p>
<p><strong>从编程的角度来看，要做的是保存一个服务器值的有序列表（可以是角度或数字列表），然后遍历此列表（或使用二分查找）以找到第一个值大于或等于检索的key的hash值的服务器，然后从该服务器取出key对应的value</strong>。<a href="#refer-anchor"><sup>[1]</sup></a>为了确保 kv 能够均匀分配到服务器上，将每个真实的 server 虚拟出多个服务器节点出来，譬如 A 服务器性能更强，就虚拟出 10 个节点，B 服务器性能弱就虚拟 5 个节点，此时就能实现负载的调节，在 spiceDb 中，权重的参数名为 replicationFactor。</p>
<h1 id="Cache-Entry"><a href="#Cache-Entry" class="headerlink" title="Cache Entry"></a>Cache Entry</h1><p>在 SpiceDB 中，一条 cache entry 的格式大概是这样的：<code>&lt;object&gt;#&lt;relation&gt;@&lt;user&gt;@&lt;snapshot timestamp&gt; → &lt;result&gt;</code>，result 有两种表示：PERMISSIONSHIP_HAS_PERMISSION（拥有权限）/ PERMISSIONSHIP_NO_PERMISSION（没有权限）。举例两个cache entry：</p>
<ul>
<li><code>document:doc1#reader@user:francesca@12345 → PERMISSIONSHIP_HAS_PERMISSION</code></li>
<li><code>document:doc1#owner@user:francesca@12345 → PERMISSIONSHIP_NO_PERMISSION</code></li>
</ul>
<p>请求落到了 server 之后，如果没有命中 snapshot timestamp，则不能直接使用缓存里的数据，而 snapshot timestamp 的选择策略又与 consistency level 参数有关（<a href="">参考这里</a>）。</p>
<h1 id="gRPC-负载均衡"><a href="#gRPC-负载均衡" class="headerlink" title="gRPC 负载均衡"></a>gRPC 负载均衡</h1><p>gRPC 的负载均衡是基于每次调用，而不是基于连接的，因为 gRPC 客户端会与所有的 server 都预先建立好连接。并且 gRPC 采取的是客户端负载均衡，由客户端在每次发起请求时根据策略选择连接。原理<a target="_blank" rel="noopener" href="https://github.com/grpc/grpc/blob/master/doc/load-balancing.md">如下</a>：</p>
<img src="https://hexo-pic-1300331708.cos.ap-guangzhou.myqcloud.com/iShot_2023-07-10_11.41.37.png" width="70%" height="70%" align=center>

<!-- ![](https://hexo-pic-1300331708.cos.ap-guangzhou.myqcloud.com/iShot_2023-07-10_11.41.37.png) -->

<p>过程：</p>
<ol>
<li>gRPC 客户端启动的时候会先请求 name resolver 服务器，获取服务端名解析出来的全部 ip 列表，还有服务端的服务配置信息（主要用于指定服务端的负载均衡策略和其他属性信息）</li>
<li>客户端实例化负载均衡策略，并向其传递服务端的配置信息，还有 ip 地址列表和其他属性</li>
<li>客户端的负载均衡实例会与resolver 返回的全部 ip 都建立连接，同时会监视所有连接的连接状态，以便及时重连</li>
<li>负载均衡实例会在客户端发起 rpc 连接时根据策略选取对应的连接来发送请求</li>
</ol>
<p>gRPC 内置了服务治理功能， 支持自定义 Resolver 来实现自定义的服务发现机制，自定义 Balancer 来实现自定义的负载均衡策略：</p>
<ul>
<li>Resolver 是解析器，用于从注册中心实时获取当前服务端的 ip:port 列表，同步发送给 Balancer</li>
<li>Balancer 是平衡器，主要有两个作用<ul>
<li>接收 Resolver 发来的服务端 ip:port 列表，同时与所有服务端建立并维护长连接状态（使用长连接可以避免每次 rpc 调用时创建新连接的开销）</li>
<li>当客户端发起 rpc 调用时，按照负载均衡算法从连接池中选择一个连接进行 rpc 调用</li>
</ul>
</li>
</ul>
<h1 id="SpiceDB-的负载均衡"><a href="#SpiceDB-的负载均衡" class="headerlink" title="SpiceDB 的负载均衡"></a>SpiceDB 的负载均衡</h1><p>下图是 spiceDB 处理一个权限验证请求的过程：</p>
<p><img src="https://hexo-pic-1300331708.cos.ap-guangzhou.myqcloud.com/2023-07-19-11-57-23.png"></p>
<h2 id="自定义-Resolver"><a href="#自定义-Resolver" class="headerlink" title="自定义 Resolver"></a>自定义 Resolver</h2><p>SpiceDB 使用自定义的名称解析器 <a target="_blank" rel="noopener" href="https://github.com/sercand/kuberesolver">kuberesolver</a> 来自动发现上线的 node，如果是在 Kubernets 上运行 SpiceDB，kuberresolver 就会使用 kubernetes API 来发现和监控服务的 IP 地址（需要在 server 的启动参数里添加如下参数）：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">--dispatch-upstream-addr=kubernetes:///spicedb.default:50053</span><br></pre></td></tr></table></figure>

<p>就可以在 service 为”spicedb”，namespace 为”default”下找到所有的 node 实例。当客户端通过 Dial 方法对指定服务进行拨号时，grpc resolver 查找注册的 Builder 实例调用其 Build() 方法构建自定义 kubeResolver。</p>
<p>代码执行流程如下：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServeCommand</span><span class="params">(programName <span class="type">string</span>, config *server.Config)</span></span> *cobra.Command &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;cobra.Command&#123;</span><br><span class="line">      Use:     <span class="string">&quot;serve&quot;</span>,</span><br><span class="line">      Short:   <span class="string">&quot;serve the permissions database&quot;</span>,</span><br><span class="line">      Long:    <span class="string">&quot;A database that stores, computes, and validates application permissions&quot;</span>,</span><br><span class="line">      PreRunE: server.DefaultPreRunE(programName),</span><br><span class="line">      <span class="comment">// RunE 绑定的函数是真正要运行的函数</span></span><br><span class="line">      RunE: termination.PublishError(<span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        server, err := config.Complete(cmd.Context())</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        signalctx := SignalContextWithGracePeriod(</span><br><span class="line">          context.Background(),</span><br><span class="line">          config.ShutdownGracePeriod,</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> server.Run(signalctx)</span><br><span class="line">      &#125;),</span><br><span class="line">      Example: server.ServeExample(programName),</span><br><span class="line">	  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Config)</span></span> Complete(ctx context.Context) (RunnableServer, <span class="type">error</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 初始化调度器</span></span><br><span class="line">  dispatcher, err = combineddispatch.NewDispatcher(</span><br><span class="line">        combineddispatch.UpstreamAddr(c.DispatchUpstreamAddr),</span><br><span class="line">        combineddispatch.UpstreamCAPath(c.DispatchUpstreamCAPath),</span><br><span class="line">        combineddispatch.GrpcPresharedKey(dispatchPresharedKey),</span><br><span class="line">        <span class="comment">// hashingConfigJSON 的默认值：&#123;&quot;loadBalancingConfig&quot;:[&#123;&quot;consistent-hashring&quot;:&#123;&quot;replicationFactor&quot;:100,&quot;spread&quot;:1&#125;&#125;]&#125;</span></span><br><span class="line">        combineddispatch.GrpcDialOpts(</span><br><span class="line">          grpc.WithUnaryInterceptor(otelgrpc.UnaryClientInterceptor()),</span><br><span class="line">          grpc.WithDefaultServiceConfig(hashringConfigJSON),</span><br><span class="line">        ),</span><br><span class="line">        combineddispatch.MetricsEnabled(c.DispatchClientMetricsEnabled),</span><br><span class="line">        combineddispatch.PrometheusSubsystem(c.DispatchClientMetricsPrefix),</span><br><span class="line">        combineddispatch.Cache(cc),</span><br><span class="line">        combineddispatch.ConcurrencyLimits(concurrencyLimits),</span><br><span class="line">      )</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDispatcher</span><span class="params">(options ...Option)</span></span> (dispatch.Dispatcher, <span class="type">error</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 在 server 的启动参数里指定了 --dispatch-upstream-addr 后，会在这里初始化resolver 实例。只有在该参数设置为：kubernetes:///spicedb.default:50053 时才会调用自定义的 kuberResolver，如果设置为ip:port(如：localhost:500053)，就会使用默认的 resolver：passthroughResolver</span></span><br><span class="line">    <span class="keyword">if</span> opts.upstreamAddr != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> opts.upstreamCAPath != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        customCertOpt, err := grpcutil.WithCustomCerts(grpcutil.VerifyCA, opts.upstreamCAPath)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        opts.grpcDialOpts = <span class="built_in">append</span>(opts.grpcDialOpts, customCertOpt)</span><br><span class="line">        opts.grpcDialOpts = <span class="built_in">append</span>(opts.grpcDialOpts, grpcutil.WithBearerToken(opts.grpcPresharedKey))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        opts.grpcDialOpts = <span class="built_in">append</span>(opts.grpcDialOpts, grpcutil.WithInsecureBearerToken(opts.grpcPresharedKey))</span><br><span class="line">        opts.grpcDialOpts = <span class="built_in">append</span>(opts.grpcDialOpts, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      opts.grpcDialOpts = <span class="built_in">append</span>(opts.grpcDialOpts, grpc.WithDefaultCallOptions(grpc.UseCompressor(<span class="string">&quot;s2&quot;</span>)))</span><br><span class="line"></span><br><span class="line">      <span class="comment">// gRPC 连接 upstreamAddr</span></span><br><span class="line">      conn, err := grpc.Dial(opts.upstreamAddr, opts.grpcDialOpts...)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">      &#125;</span><br><span class="line">      redispatch = remote.NewClusterDispatcher(v1.NewDispatchServiceClient(conn), conn, remote.ClusterDispatcherConfig&#123;</span><br><span class="line">        KeyHandler:             &amp;keys.CanonicalKeyHandler&#123;&#125;,</span><br><span class="line">        DispatchOverallTimeout: opts.remoteDispatchTimeout,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gRPC 内部经过多个调用链：grpc.Dial -&gt; grpc.DialContext -&gt; grpc.newCCResolverWrapper -&gt;</span></span><br><span class="line"><span class="comment">// 最终调用到了自定义的 resolver</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *kubeBuilder)</span></span> Build(target resolver.Target, cc resolver.ClientConn, opts resolver.BuildOptions) (resolver.Resolver, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> b.k8sClient == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> cl, err := NewInClusterK8sClient(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">        b.k8sClient = cl</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ti, err := parseResolverTarget(target)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ti.serviceNamespace == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">      ti.serviceNamespace = getCurrentNamespaceOrDefault()</span><br><span class="line">    &#125;</span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    r := &amp;kResolver&#123;</span><br><span class="line">      target:    ti,</span><br><span class="line">      ctx:       ctx,</span><br><span class="line">      cancel:    cancel,</span><br><span class="line">      cc:        cc,</span><br><span class="line">      rn:        <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>),</span><br><span class="line">      k8sClient: b.k8sClient,</span><br><span class="line">      t:         time.NewTimer(defaultFreq),</span><br><span class="line">      freq:      defaultFreq,</span><br><span class="line"></span><br><span class="line">      endpoints: endpointsForTarget.WithLabelValues(ti.String()),</span><br><span class="line">      addresses: addressesForTarget.WithLabelValues(ti.String()),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在一个 goroutinue 里持续监控所有注册到 k8s 的 endpoint</span></span><br><span class="line">    <span class="keyword">go</span> until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      r.wg.Add(<span class="number">1</span>)</span><br><span class="line">      err := r.watch()</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != io.EOF &#123;</span><br><span class="line">        grpclog.Errorf(<span class="string">&quot;kuberesolver: watching ended with error=&#x27;%v&#x27;, will reconnect again&quot;</span>, err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, time.Second, ctx.Done())</span><br><span class="line">    <span class="keyword">return</span> r, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewInClusterK8sClient</span><span class="params">()</span></span> (K8sClient, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 在 pod 里获取环境变量，最终构造成 k8s 内部 api 的调用地址</span></span><br><span class="line">  host, port := os.Getenv(<span class="string">&quot;KUBERNETES_SERVICE_HOST&quot;</span>), os.Getenv(<span class="string">&quot;KUBERNETES_SERVICE_PORT&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(host) == <span class="number">0</span> || <span class="built_in">len</span>(port) == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unable to load in-cluster configuration, KUBERNETES_SERVICE_HOST and KUBERNETES_SERVICE_PORT must be defined&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    token, err := ioutil.ReadFile(serviceAccountToken)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    ca, err := ioutil.ReadFile(serviceAccountCACert)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    certPool := x509.NewCertPool()</span><br><span class="line">    certPool.AppendCertsFromPEM(ca)</span><br><span class="line">    transport := &amp;http.Transport&#123;TLSClientConfig: &amp;tls.Config&#123;</span><br><span class="line">      MinVersion: tls.VersionTLS10,</span><br><span class="line">      RootCAs:    certPool,</span><br><span class="line">    &#125;&#125;</span><br><span class="line">    httpClient := &amp;http.Client&#123;Transport: transport, Timeout: time.Nanosecond * <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">    client := &amp;k8sClient&#123;</span><br><span class="line">      <span class="comment">// k8s 内部 api 的 url 地址</span></span><br><span class="line">      host:       <span class="string">&quot;https://&quot;</span> + net.JoinHostPort(host, port),</span><br><span class="line">      token:      <span class="type">string</span>(token),</span><br><span class="line">      httpClient: httpClient,</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 SpiceDB 的可用 node，其实就是访问 k8s 提供的服务注册 api 实现的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getEndpoints</span><span class="params">(client K8sClient, namespace, targetName <span class="type">string</span>)</span></span> (Endpoints, <span class="type">error</span>) &#123;</span><br><span class="line">    u, err := url.Parse(fmt.Sprintf(<span class="string">&quot;%s/api/v1/namespaces/%s/endpoints/%s&quot;</span>,</span><br><span class="line">      client.Host(), namespace, targetName))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Endpoints&#123;&#125;, err</span><br><span class="line">    &#125;</span><br><span class="line">    req, err := client.GetRequest(u.String())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Endpoints&#123;&#125;, err</span><br><span class="line">    &#125;</span><br><span class="line">    resp, err := client.Do(req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Endpoints&#123;&#125;, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    <span class="keyword">if</span> resp.StatusCode != http.StatusOK &#123;</span><br><span class="line">      <span class="keyword">return</span> Endpoints&#123;&#125;, fmt.Errorf(<span class="string">&quot;invalid response code %d for service %s in namespace %s&quot;</span>, resp.StatusCode, targetName, namespace)</span><br><span class="line">    &#125;</span><br><span class="line">    result := Endpoints&#123;&#125;</span><br><span class="line">    err = json.NewDecoder(resp.Body).Decode(&amp;result)</span><br><span class="line">    <span class="keyword">return</span> result, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------------------------------------</span><br><span class="line"><span class="comment">// 监控 endpoint</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(k *kResolver)</span></span> watch() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> k.wg.Done()</span><br><span class="line">    <span class="comment">// watch endpoints lists existing endpoints at start</span></span><br><span class="line">    sw, err := watchEndpoints(k.ctx, k.k8sClient, k.target.serviceNamespace, k.target.serviceName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-k.ctx.Done():</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        <span class="comment">// 兜底策略：定期每 30 分钟获取一次全部 endpoint 的实例信息，检查是否有新的 endpoint。resolve()函数内部也是调用了 handle()函数</span></span><br><span class="line">      <span class="keyword">case</span> &lt;-k.t.C:</span><br><span class="line">        k.resolve()</span><br><span class="line">      <span class="keyword">case</span> &lt;-k.rn:</span><br><span class="line">        k.resolve()</span><br><span class="line">        <span class="comment">// 发现新的 endpoint</span></span><br><span class="line">      <span class="keyword">case</span> up, hasMore := &lt;-sw.ResultChan():</span><br><span class="line">        <span class="keyword">if</span> hasMore &#123;</span><br><span class="line">          k.handle(up.Object)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 持续监控所有注册到 k8s 的 endpoint</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watchEndpoints</span><span class="params">(ctx context.Context, client K8sClient, namespace, targetName <span class="type">string</span>)</span></span> (watchInterface, <span class="type">error</span>) &#123;</span><br><span class="line">    u, err := url.Parse(fmt.Sprintf(<span class="string">&quot;%s/api/v1/watch/namespaces/%s/endpoints/%s&quot;</span>,</span><br><span class="line">      client.Host(), namespace, targetName))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    req, err := client.GetRequest(u.String())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    req = req.WithContext(ctx)</span><br><span class="line">    resp, err := client.Do(req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> resp.StatusCode != http.StatusOK &#123;</span><br><span class="line">      <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;invalid response code %d for service %s in namespace %s&quot;</span>, resp.StatusCode, targetName, namespace)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newStreamWatcher(resp.Body), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结调用流程：</p>
<ul>
<li>客户端启动时，通过 kuberesolver.RegisterInCluster() 注册自定义的 kubeResolver</li>
<li>在cobra 的 Command（serve）中通过 grpc.Dial(opts.upstreamAddr, opts.grpcDialOpts…) 来初始化自定义的kubeResolver<ul>
<li>grpc.DialContext()方法内部解析 URI(kubernetes:///spicedb.default:50053)，解析到协议类型为 kubernetes，因此匹配到了自定义的kubeResolver，调用kubeBuilder.Build（）方法构建 kubeResolver，同时开启 goroutinue，通过此 resolver 更新被调用服务(spicedb.default)对应的实例列表（所有注册到该服务的server node）</li>
</ul>
</li>
<li>grpc 底层 LB 库会对每个服务实例创建一个 subConnection，最终根据自定义的负载均衡策略，在每次发起 gRPC 调用时选择合适的 subConnection 处理请求</li>
</ul>
<p>参考其他人做的流程图（把图中的nsResolver替换成kubeResolver即可）：<br><img src="https://hexo-pic-1300331708.cos.ap-guangzhou.myqcloud.com/2023-07-19-11-38-45.png"></p>
<h2 id="自定义-Balancer"><a href="#自定义-Balancer" class="headerlink" title="自定义 Balancer"></a>自定义 Balancer</h2><p>自定义的 resolver 解析到了所有 spiceDB node 的真实地址列表后，Balancer 负责控制客户端和这些<strong>服务端的地址之一</strong>建立连接（只会建立一个正常的连接）并使用该连接处理所有 rpc 请求。</p>
<p>通过 kubersolver，grpc-go 客户端就可以找到所有SpiceDB 的 node，SpiceDB 自定义了一个负载均衡器来支持一致性哈希算法，该算法会聚合request 里的不同参数(如下所示)再计算哈希值：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cr/&lt;req.Metadata.AtRevision&gt;@&lt;req.ResourceRelation&gt;@&lt;req.ResourceIds&gt;@&lt;req.Subject&gt;@&lt;req.ResultsSetting&gt;</span><br></pre></td></tr></table></figure>
<p>计算 hash key 的算法</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// checkRequestToKey converts a check request into a cache key based on the relation</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkRequestToKey</span><span class="params">(req *v1.DispatchCheckRequest, option dispatchCacheKeyHashComputeOption)</span></span> DispatchCacheKey &#123;</span><br><span class="line">	<span class="keyword">return</span> dispatchCacheKeyHash(checkViaRelationPrefix, req.Metadata.AtRevision, option,</span><br><span class="line">		hashableRelationReference&#123;req.ResourceRelation&#125;,</span><br><span class="line">		hashableIds(req.ResourceIds),</span><br><span class="line">		hashableOnr&#123;req.Subject&#125;,</span><br><span class="line">		hashableResultSetting(req.ResultsSetting),</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回顾上面的图，dispatchServiceClient.DispatchCheck 函数通过 gRPC 调用其他 node 的时候，底层实际上调用了grpc.(*pickerWrapper).pick() 函数，spiceDB 自定义的 Balancer 实现接口：balancer.Picker:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每次 rpc 调用时，返回 chosen 对应的连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *consistentHashringPicker)</span></span> Pick(info balancer.PickInfo) (balancer.PickResult, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 存储在 context 中的 key（CtxKey）用于计算哈希值，这个 key 就是上面所说的 request 参数被聚合后的结果</span></span><br><span class="line">  key := info.Ctx.Value(CtxKey).([]<span class="type">byte</span>)</span><br><span class="line">  <span class="comment">// FindN 函数用于从哈希环里选择节点</span></span><br><span class="line">	members, err := p.hashring.FindN(key, p.spread)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> balancer.PickResult&#123;&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	index := <span class="number">0</span></span><br><span class="line">  <span class="comment">// 如果 spread 大于 1，会选择一个随机数</span></span><br><span class="line">	<span class="keyword">if</span> p.spread &gt; <span class="number">1</span> &#123;</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> should look into other options for this to avoid locking; we mostly use spread 1 so it&#x27;s not urgent</span></span><br><span class="line">		<span class="comment">// rand is not safe for concurrent use</span></span><br><span class="line">		p.Lock()</span><br><span class="line">		index = p.rand.Intn(<span class="type">int</span>(p.spread))</span><br><span class="line">		p.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	chosen := members[index].(subConnMember)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> balancer.PickResult&#123;</span><br><span class="line">		SubConn: chosen.SubConn,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从哈希环里选择 num 个虚拟节点返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Hashring)</span></span> FindN(key []<span class="type">byte</span>, num <span class="type">uint8</span>) ([]Member, <span class="type">error</span>) &#123;</span><br><span class="line">	h.RLock()</span><br><span class="line">	<span class="keyword">defer</span> h.RUnlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="type">int</span>(num) &gt; <span class="built_in">len</span>(h.nodes) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, ErrNotEnoughMembers</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	keyHash := h.hasher(key)</span><br><span class="line">  <span class="comment">// 哈希环可以展开成一个首尾相连的数组，此处用二分法查找</span></span><br><span class="line">	vnodeIndex := sort.Search(<span class="built_in">len</span>(h.virtualNodes), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> h.virtualNodes[i].hashvalue &gt;= keyHash</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	alreadyFoundNodeKeys := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	foundNodes := <span class="built_in">make</span>([]Member, <span class="number">0</span>, num)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(h.virtualNodes) &amp;&amp; <span class="built_in">len</span>(foundNodes) &lt; <span class="type">int</span>(num); i++ &#123;</span><br><span class="line">    <span class="comment">// 连续选择 num 个虚拟节点</span></span><br><span class="line">		boundedIndex := (i + vnodeIndex) % <span class="built_in">len</span>(h.virtualNodes)</span><br><span class="line">		candidate := h.virtualNodes[boundedIndex]</span><br><span class="line">		<span class="keyword">if</span> _, ok := alreadyFoundNodeKeys[candidate.members.nodeKey]; !ok &#123;</span><br><span class="line">			foundNodes = <span class="built_in">append</span>(foundNodes, candidate.members.member)</span><br><span class="line">			alreadyFoundNodeKeys[candidate.members.nodeKey] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> foundNodes, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>哈希环的处理</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 发现新的 node 时，往哈希环里添加缓存节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Hashring)</span></span> Add(member Member) <span class="type">error</span> &#123;</span><br><span class="line">  <span class="comment">// nodeKeyString 的值：ip+port</span></span><br><span class="line">	nodeKeyString := member.Key()</span><br><span class="line"></span><br><span class="line">	h.Lock()</span><br><span class="line">	<span class="keyword">defer</span> h.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _, ok := h.nodes[nodeKeyString]; ok &#123;</span><br><span class="line">		<span class="comment">// already have node, bail</span></span><br><span class="line">		<span class="keyword">return</span> ErrMemberAlreadyExists</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nodeHash := h.hasher([]<span class="type">byte</span>(nodeKeyString))</span><br><span class="line"></span><br><span class="line">	newNodeRecord := nodeRecord&#123;</span><br><span class="line">		nodeHash,</span><br><span class="line">		nodeKeyString,</span><br><span class="line">		member,</span><br><span class="line">		<span class="literal">nil</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtualNodeBuffer是一个 10 bit 的数组，高 8 位存储了节点的哈希 key，最后 2 位存储了对应的虚拟节点索引值</span></span><br><span class="line">	virtualNodeBuffer := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">10</span>)</span><br><span class="line">	binary.LittleEndian.PutUint64(virtualNodeBuffer, nodeHash)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="type">uint16</span>(<span class="number">0</span>); i &lt; h.replicationFactor; i++ &#123;</span><br><span class="line">		binary.LittleEndian.PutUint16(virtualNodeBuffer[<span class="number">8</span>:], i)</span><br><span class="line">    <span class="comment">// 组装成 10 位的数组后再计算一次哈希值</span></span><br><span class="line">		virtualNodeHash := h.hasher(virtualNodeBuffer)</span><br><span class="line"></span><br><span class="line">		virtualNode := virtualNode&#123;</span><br><span class="line">			virtualNodeHash,</span><br><span class="line">			newNodeRecord,</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		newNodeRecord.virtualNodes = <span class="built_in">append</span>(newNodeRecord.virtualNodes, virtualNode)</span><br><span class="line">		h.virtualNodes = <span class="built_in">append</span>(h.virtualNodes, virtualNode)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 将所有的虚拟节点排序</span></span><br><span class="line">	sort.Sort(h.virtualNodes)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Add the node to our map of nodes</span></span><br><span class="line">	h.nodes[nodeKeyString] = newNodeRecord</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除服务节点对应的所有虚拟节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Hashring)</span></span> Remove(member Member) <span class="type">error</span> &#123;</span><br><span class="line">	nodeKeyString := member.Key()</span><br><span class="line"></span><br><span class="line">	h.Lock()</span><br><span class="line">	<span class="keyword">defer</span> h.Unlock()</span><br><span class="line"></span><br><span class="line">	foundNode, ok := h.nodes[nodeKeyString]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="comment">// don&#x27;t have the node, bail</span></span><br><span class="line">		<span class="keyword">return</span> ErrMemberNotFound</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	indexesToRemove := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, h.replicationFactor)</span><br><span class="line">	<span class="keyword">for</span> _, vnode := <span class="keyword">range</span> foundNode.virtualNodes &#123;</span><br><span class="line">		vnode := vnode</span><br><span class="line">		vnodeIndex := sort.Search(<span class="built_in">len</span>(h.virtualNodes), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> !h.virtualNodes[i].less(vnode)</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">if</span> vnodeIndex &gt;= <span class="built_in">len</span>(h.virtualNodes) &#123;</span><br><span class="line">			<span class="keyword">return</span> spiceerrors.MustBugf(<span class="string">&quot;unable to find vnode to remove: %020d:%020d:%s&quot;</span>, vnode.hashvalue, vnode.members.hashvalue, vnode.members.nodeKey)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		indexesToRemove = <span class="built_in">append</span>(indexesToRemove, vnodeIndex)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sort.Slice(indexesToRemove, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="comment">// <span class="doctag">NOTE:</span> this is a reverse sort!</span></span><br><span class="line">		<span class="keyword">return</span> indexesToRemove[j] &lt; indexesToRemove[i]</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(indexesToRemove) != <span class="type">int</span>(h.replicationFactor) &#123;</span><br><span class="line">		<span class="keyword">return</span> spiceerrors.MustBugf(<span class="string">&quot;found wrong number of vnodes to remove: %d != %d&quot;</span>, <span class="built_in">len</span>(indexesToRemove), h.replicationFactor)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将要删除的元素都放到数组的末尾</span></span><br><span class="line">	<span class="keyword">for</span> i, indexToRemove := <span class="keyword">range</span> indexesToRemove &#123;</span><br><span class="line">		<span class="comment">// Swap this index for a later one</span></span><br><span class="line">		h.virtualNodes[indexToRemove] = h.virtualNodes[<span class="built_in">len</span>(h.virtualNodes)<span class="number">-1</span>-i]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Truncate and sort the nodelist</span></span><br><span class="line">	h.virtualNodes = h.virtualNodes[:<span class="built_in">len</span>(h.virtualNodes)-<span class="built_in">len</span>(indexesToRemove)]</span><br><span class="line">	sort.Sort(h.virtualNodes)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Remove the node from our map</span></span><br><span class="line">	<span class="built_in">delete</span>(h.nodes, nodeKeyString)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一个权限检查请求的查找过程如下：</p>
<ul>
<li>根据要查找的对象计算哈希值</li>
<li>哈希值写入 gRPC 的 context 中发起 gRPC 调用</li>
<li>gRPC 根据该哈希值查找哈希环里 &gt;= 该值的一个虚拟节点</li>
<li>从虚拟节点里找到对应的真实server node，gRPC 使用该连接对 node 发起请求</li>
<li>spiceDB node 接受请求后同样使用哈希值查找本身的 cache</li>
<li>cache 没有命中的话就查找数据库，然后将结果 set 进 cache 中（ttl 为 20s），在 cache 里的 key 就是该对象的哈希值</li>
</ul>
<p>注意：</p>
<ul>
<li>哈希环存储的是所有虚拟节点的哈希值，并不存储 cache 里的哈希值</li>
<li>不管 spiceDB 的 node 是增加还是减少，其实都不会迁移 cache 里的值</li>
<li>如果新增了一个 node，就会在哈希环里虚拟出多个虚拟节点。此时 node 的 cache 是空的，所有落到该 node 的请求都必须查询数据库后才能写入 cache，如果其他 node 已经缓存了要查询的结果也没用，只等等到 ttl 过期后淘汰。删除也同理</li>
</ul>
<h1 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h1><p>在 Zanzibar 中，除了使用热点缓存技术之外，还使用了其他缓存技术，包括：relationship cache（将一个热点 object 相关的全部 relation tuple 提前加载到内存中）；Leopard Indexing System（用于持续更新用户权限的非结构化数据，可以支持权限集合的快速计算）。SpiceDB 目前对这两种技术的实现还停留在 <a target="_blank" rel="noopener" href="https://github.com/authzed/spicedb/issues/207">proposal</a> 阶段。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><div id="refer-anchor"></div>

<p>[1] <a target="_blank" rel="noopener" href="https://berryjam.github.io/2018/05/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C(Consistent-hashing)%E7%AE%97%E6%B3%95/">一致性哈希(Consistent hashing)算法</a><br>[2] <a target="_blank" rel="noopener" href="https://web.stanford.edu/class/cs168/l/l1.pdf">CS168: The Modern Algorithmic Toolbox Lecture #1: Introduction and Consistent Hashing</a><br>[3] <a target="_blank" rel="noopener" href="https://itnext.io/introducing-consistent-hashing-9a289769052e">Introducing Consistent Hashing</a><br>[4] <a target="_blank" rel="noopener" href="https://blog.csdn.net/u013536232/article/details/108556544">grpc进阶篇之resolver</a><br>[5] <a target="_blank" rel="noopener" href="https://toutiao.io/posts/tazdpo4/preview">gRPC Name Resolver 原理及实践</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">kylinlin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://kylinlingh.github.io/2023/06/28/%E6%BA%90%E7%A0%81-spicedb-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8B%E7%AC%AC%E4%B8%80%E7%AF%87-%E7%83%AD%E7%82%B9%E7%BC%93%E5%AD%98/">https://kylinlingh.github.io/2023/06/28/%E6%BA%90%E7%A0%81-spicedb-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8B%E7%AC%AC%E4%B8%80%E7%AF%87-%E7%83%AD%E7%82%B9%E7%BC%93%E5%AD%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://kylinlingh.github.io">LGH's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%8E%88%E6%9D%83/">授权</a><a class="post-meta__tags" href="/tags/%E9%9B%B6%E4%BF%A1%E4%BB%BB/">零信任</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2023/06/19/%E7%AC%94%E8%AE%B0-Zanzibar-Google%E2%80%99s-Consistent-Global-Authorization-System/"><span>[笔记]Zanzibar: Google’s Consistent, Global Authorization System</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '55d75c7dbe6839be8769',
  clientSecret: '0c19d8eb1e620f8968cc37090f307f82a3c0cbef',
  repo: 'kylinlingh.github.io',
  owner: 'kylinlingh',
  admin: 'kylinlingh',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2019/12/20/kXR6KLoOcwDsUQy.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2022 - 2023 By kylinlin</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><!--if(theme.busuanzi.page_pv)--><!--  span#busuanzi_container_page_pv!= theme.busuanzi.page_pv_header--><!--    span#busuanzi_value_page_pv--><!--    span!=theme.busuanzi.page_pv_footer--><!--else--><span id="busuanzi_container_site_uv">欢迎您，第<span id="busuanzi_value_site_uv"></span><span>位访客</span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv">总访问量为<span id="busuanzi_value_site_pv"></span><span>次</span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script src="/js/search/algolia.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>