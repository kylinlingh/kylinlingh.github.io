<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>安全屋</title>
  
  <subtitle>Building a zero trust system from ground zero.</subtitle>
  <link href="https://kylinlingh.github.io/atom.xml" rel="self"/>
  
  <link href="https://kylinlingh.github.io/"/>
  <updated>2023-01-31T02:33:43.307Z</updated>
  <id>https://kylinlingh.github.io/</id>
  
  <author>
    <name>kylinlin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2023年总结</title>
    <link href="https://kylinlingh.github.io/2023/01/31/2023%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <id>https://kylinlingh.github.io/2023/01/31/2023%E5%B9%B4%E6%80%BB%E7%BB%93/</id>
    <published>2023-01-30T16:00:00.000Z</published>
    <updated>2023-01-31T02:33:43.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开源项目开发"><a href="#开源项目开发" class="headerlink" title="开源项目开发"></a>开源项目开发</h1><ul><li>复现AWS的IAM系统</li></ul><h1 id="经济分析"><a href="#经济分析" class="headerlink" title="经济分析"></a>经济分析</h1><ul><li>美股的基本面分析</li><li>阅读分析财报100份</li></ul><h1 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h1><p>计划阅读书单：</p><ul><li>《置身事内：中国政府与经济发展》</li><li>《财报就像一本故事书》</li><li>《贝佐斯致股东的信》</li><li>《巴菲特致股东的信》</li><li>《心里突破：审判中的心理学原理与方法》</li><li>《货币金融学》</li><li>《货币战争》</li><li>《当下的力量》</li><li>《反脆弱：从不确定性中获益》</li><li>《系统之美：决策者的系统思考》</li></ul><p>阅读进度：</p><ul><li>1月：<ul><li>《当下的力量》：完成</li><li>《财报就像一本故事书》：50%</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;开源项目开发&quot;&gt;&lt;a href=&quot;#开源项目开发&quot; class=&quot;headerlink&quot; title=&quot;开源项目开发&quot;&gt;&lt;/a&gt;开源项目开发&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;复现AWS的IAM系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;经济分析&quot;&gt;&lt;a href=&quot;#经</summary>
      
    
    
    
    <category term="个人感悟" scheme="https://kylinlingh.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="个人感悟" scheme="https://kylinlingh.github.io/tags/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>企业账号安全体系建设之单点登录系统设计</title>
    <link href="https://kylinlingh.github.io/2022/10/17/%E4%BC%81%E4%B8%9A%E8%B4%A6%E5%8F%B7%E5%AE%89%E5%85%A8%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE%E4%B9%8B%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://kylinlingh.github.io/2022/10/17/%E4%BC%81%E4%B8%9A%E8%B4%A6%E5%8F%B7%E5%AE%89%E5%85%A8%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE%E4%B9%8B%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-10-17T04:49:05.000Z</published>
    <updated>2023-01-29T08:41:17.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>单点登录（SSO，Single Sign On）是一种身份验证解决方案，可让用户通过一次性用户身份验证登录多个相互信任的应用程序和网站。</p><p>SSO能解决的问题：</p><ul><li>提高用户体验：用户不必在每个系统中都进行注册、登录</li><li>减轻开发人员的负担：开发人员不需要为每个系统都设计一个单独的账号和登录系统，并且很难几乎不可能要求所有开发人员保证这些系统都达到合格的安全水位以上</li><li>改善安全状况：通过收敛用户的登录入口，可以审计用户的登录行为</li></ul><p>SSO有以下几种协议来对用户进行身份验证：</p><ul><li>SAML（Security Assertion Markup Language, 安全断言标记语言）：SAML 使用 XML 来交换用户标识数据，基于 SAML 的 SSO 服务提供更好的安全性和灵活性，因为应用程序不需要在其系统上存储用户凭证。因为该协议不在本文介绍的重点之内，详情参考<a href="#refer-anchor"><sup>[7]</sup></a>。</li><li>OIDC（OpenID Connect，）：是使用一组用户凭证访问多个站点的方法，譬如使用微信账号登录其他网站的场景，就是这种开放标准的应用。</li><li>Kerberos：一种基于票证的身份验证系统，可让两方或多方在网络上相互验证其身份。它使用安全密码学来防止未经授权访问在服务器、客户端和密钥分发中心之间传输的标识信息。<strong>所谓的票证，可以理解为多个请求体参数，这些参数主要包括客户端的Name，IP，需要访问的网络服务的地址Server IP，ST的有效时间，时间戳以及用于客户端和服务端之间通信的Session Key（只在一次Session会话中起作用，即使密钥被劫持，等到密钥被破解可能这次会话都早已结束）</strong></li></ul><h1 id="Kerberos协议"><a href="#Kerberos协议" class="headerlink" title="Kerberos协议"></a>Kerberos协议</h1><p>感慨于kerberos协议的精妙，所以研究了一下整个认证过程，概括如下<a href="#refer-anchor"><sup>[2]</sup></a></p><p><img src="https://hexo-pic-1300331708.cos.ap-guangzhou.myqcloud.com/2023-01-06-15-23-43.png" alt="kerberos协议认证过程"></p><ol><li>认证服务器首先在数据库里存储客户端和服务端的身份信息（譬如ip，用户名）和双方的密钥（该密钥通过密码生成）</li><li>客户端首先与认证服务器连接，主要是验证客户端是否已经在数据库里（用户名和ip），认证通过后返回一个被加密的<strong>票据授予票据</strong>（主要包含了客户端的Name，IP，当前时间戳等），客户端用自己的密钥解密部份票据内容后会根据时间戳判断该时间戳与自己发送请求时的时间之间的差值是否大于5分钟，如果大于五分钟则认为该认证服务器是伪造的，认证至此失败；另一部份票据内容是用票据授予服务器的密钥加密的，里面保存了客户端的身份信息，客户端无法解密。</li><li>客户端一次性将三种内容发送给<strong>票据授予服务器</strong>，包括：服务端IP，自身的身份信息，第2步里无法解密的部份票据授予票据。票据授予服务器首先验证服务端IP是否在数据库内，再判断时延，最后票据授予服务器用自己的密钥解开票据授予票据获取到认证服务器封装好的客户端信息，将该信息与客户端发送过来的自身身份信息比较。一致后就认为通过了验证并返回用服务端密钥加密的票证。</li><li>客户端用服务端的密钥加密自身的身份信息，与第三步获得的票据一起发送给服务端。服务端解密后验证身份信息是否与票据里的身份信息一致，然后将接受请求的响应加密后返回。客户端解密后会验证服务端身份，至此双方完成了身份验证。</li></ol><p>总结，核心步骤：</p><ol><li>验证client与server的ip是否在数据库中</li><li>验证时间戳是否超出时延</li><li>AS用TGS的密钥加密client的身份信息，让TGS解密后验证是否一致</li><li>TGS用server的密钥加密client的身份信息，让server解密后验证是否一致</li></ol><h1 id="OIDC协议"><a href="#OIDC协议" class="headerlink" title="OIDC协议"></a>OIDC协议</h1><p>OIDC 是基于 OAuth 2.0 构建的身份认证框架协议，但是 OIDC 与 OAuth2.0 有概念的区别：</p><ul><li>OAuth2.0 是一种授权协议，主要<strong>用于资源授权（只做一件事）</strong></li><li>OIDC 是 OAuth 2.0 协议的超集，能够<strong>认证用户并完成资源授权（做了两件事）</strong></li></ul><p>在介绍OIDC之前，先介绍OAuth协议，OAuth 1.0 现在已经是废弃状态，不需要研究。OAuth 2.0 的授权流程如下：</p><p><img src="https://hexo-pic-1300331708.cos.ap-guangzhou.myqcloud.com/2023-01-06-16-13-53.png" alt="OAuth2.0 授权流程"></p><ol><li>第三方应用要求用户登录，用户选择了使用微信帐号登录</li><li>第三方应用拉起微信APP，微信APP会弹出一个登录确认框</li><li>用户点击确认按钮后微信会给微信服务平台发送一个请求</li><li>微信服务平台给微信返回一个授权码，然后微信重新拉起第三方应用并附带授权码</li><li>第三方应用APP会将授权码传递给服务端，由服务端向微信的服务平台发起请求，并附带上授权码，app_id和app_secret（这两者都是第三方应用在微信服务平台上注册时生成的）</li><li>微信服务平台返回一个access_token，如果需要，还会返回 refresh_token。</li><li>第三方应用使用这个access_token访问微信服务平台，微信服务平台验证了access_token之后就返回用户的微信帐号信息</li></ol><p>可以看到，整个过程中唯一可能让用户输入帐号密码的地方就是第二步拉起微信APP时，如果你此时在微信退出了登录就会让你输入账号密码来认证，但这个认证过程不在 OAuth2.0 协议的流程里，因此 OAuth2.0 并不是身份认证协议。</p><p>问题1: 为什么第四步要引入授权码，没有授权码环节可以吗？<br>如果没有了授权码，那么第四步就变成了微信服务平台直接给第三方应用服务端返回 access_token，<strong>注意，不能将 access_token 返回给第三方应用APP的客户端，这样会导致 access_token 存在失窃的安全风险</strong>，然后第三方应用服务端就直接拿着 access_token 去拿数据。此时，原本第四步里微信会重新拉起第三方应用的这个步骤就消失了，意味着第三方应用实际上已经登录完成了，但你仍然停留在微信的界面上并且没人通知你登录成功，想想就知道这个用户体验就很差。所以授权码的作用就是为了<strong>重新建立起第三方应用的一次连接，但又不能让访问令牌暴露出去</strong>。授权码就是一个临时的、间接的凭证，并且可以直接返回给第三方应用APP，甚至直接暴露在网络上也没问题，而 access_token 是安全保密性要求极高的令牌，只能在服务端之间用https传输。</p><p>问题2: 如果窃取了授权码，是否也可以获取到 access_token？<br>需要同步窃取到第三方应用的app_id和app_secret，并且在授权码尚未过期的时间内可以。</p><p>问题3: 不使用授权码，在第四步让微信重新拉起第三方应用并用https传递 access_token 是否可以？<br>https是用来保证传输安全的，access_token 到达了第三方应用APP端后会遭遇怎样的风险是未知的，可能移动端本身已经被hack了，黑客已经拿到了https的证书，此时就可以直接解开并获得 access_token 了。所以传输过程安全了，并不代表存储就是安全的。</p><hr><p>看完了 OAuth2.0 协议之后，再看 OIDC 协议的流程：</p><p><img src="https://hexo-pic-1300331708.cos.ap-guangzhou.myqcloud.com/2023-01-06-18-24-06.png" alt="OIDC协议工作时许图"></p><p>可以看到,用 OAuth 2.0 实现 OIDC 的最关键的方法是在原有 OAuth 2.0 流程的基础上增加 ID 令牌（id_token）和 UserInfo 端点（可以理解为认证平台的一个接口，用于给第三方应用获取用户信息，譬如： /oauth2/userInfo）。id_token是一个jwt格式的令牌，得益于jwt的自包含性，紧凑性以及防篡改机制，使得 id_token 可以安全的传递给第三方客户端程序并且容易被验证。第三方软件可以通过解析 id_token 获取关键用户标识信息（其实就是user_id，如果第三方系统不需要获取更详细的用户信息，就不需要房屋UserInfo端点）来记录用户状态，然后通过 Userinfo 端点来获取更详细的用户信息。<strong>有了用户态和用户信息，也就理所当然地实现了一个身份认证</strong>。</p><blockquote><p>ID Token的主要构成部分如下（使用OAuth2流程的OIDC）<a href="#refer-anchor"><sup>[4]</sup></a>。</p><ol><li>iss = Issuer Identifier：必须。提供认证信息者的唯一标识。一般是一个https的url（不包含querystring和fragment部分）。</li><li>sub = Subject Identifier：必须。iss提供的EU的标识，在iss范围内唯一。它会被RP用来标识唯一的用户。最长为255个ASCII个字符。</li><li>aud = Audience(s)：必须。标识ID Token的受众。必须包含OAuth2的client_id</li><li>exp = Expiration time：必须。过期时间，超过此时间的ID Token会作废不再被验证通过。</li><li>iat = Issued At Time：必须。JWT的构建的时间。</li><li>auth_time = AuthenticationTime：EU完成认证的时间。如果RP发送AuthN请求的时候携带max_age的参数，则此Claim是必须的。</li><li>nonce：RP发送请求的时候提供的随机字符串，用来减缓重放攻击，也可以来关联ID Token和RP本身的Session信息。</li><li>acr = Authentication Context Class Reference：可选。表示一个认证上下文引用值，可以用来标识认证上下文类。</li><li>amr = Authentication Methods References：可选。表示一组认证方法。</li><li>azp = Authorized party：可选。结合aud使用。只有在被认证的一方和受众（aud）不一致时才使用此值，一般情况下很少使用。</li></ol></blockquote><p>典型的例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;iss&quot;: &quot;https://server.example.com&quot;,</span><br><span class="line">    &quot;sub&quot;: &quot;24400320&quot;,</span><br><span class="line">    &quot;aud&quot;: &quot;s6BhdRkqt3&quot;,</span><br><span class="line">    &quot;nonce&quot;: &quot;n-0S6_WzA2Mj&quot;,</span><br><span class="line">    &quot;exp&quot;: 1311281970,</span><br><span class="line">    &quot;iat&quot;: 1311280970,</span><br><span class="line">    &quot;auth_time&quot;: 1311280969,</span><br><span class="line">    &quot;acr&quot;: &quot;urn:mace:incommon:iap:silver&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OIDC的AuthN请求中scope参数必须要有一个值为的openid的参数（后面会详细介绍AuthN请求所需的参数），用来区分这是一个OIDC的Authentication请求，而不是OAuth2的Authorization请求。</p><h1 id="基于-OIDC-协议实现的-SSO-系统"><a href="#基于-OIDC-协议实现的-SSO-系统" class="headerlink" title="基于 OIDC 协议实现的 SSO 系统"></a>基于 OIDC 协议实现的 SSO 系统</h1><p>假设一个第三方软件有三个子应用，对应的域名分别是 a1.com、a2.com、a3.com，现在要设计一个SSO系统让用户登录了 a1.com 之后也能顺利登录其他两个域名，这就是SSO（单点登录：一次登录，畅通所有）</p><p><img src="https://hexo-pic-1300331708.cos.ap-guangzhou.myqcloud.com/2023-01-09-14-35-54.png" alt="基于OIDC实现的SSO"></p><p>当用户在 a1.com 登录成功后，OP会为该用户创建 session，用户在登录a2.com或a3.com时会在 cookie 中携带 session_id，从而避免了反复输入密码。</p><p>Q1：用 access_token 也可以拿到用户信息，为什么还要引入 id_token ？<a href="#refer-anchor"><sup>[1]</sup></a><br>access_token 永远不能被任何第三方软件去解析，就是一个令牌，用来后续请求受保护资源；而 id_token 是可以直接被第三方软件解析的。而且，这两种令牌还具有不同的生命周期，id_token 通常会很快过期，而 access_token 可以在用户离开后的很长时间内用于获取受保护资源。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><div id="refer-anchor"></div><p>[1] <a href="https://zq99299.github.io/note-book/oath2/">OAuth 2.0 实战</a><br>[2] <a href="https://seevae.github.io/2020/09/12/%E8%AF%A6%E8%A7%A3kerberos%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/">详解kerberos认证原理</a><br>[3] <a href="https://learn.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow">Microsoft identity platform and OAuth 2.0 authorization code flow</a><br>[4] <a href="https://www.cnblogs.com/linianhui/p/openid-connect-core.html">[认证 &amp; 授权] 4. OIDC（OpenId Connect）身份认证（核心部分）</a><br>[5] <a href="https://openid.net/specs/openid-connect-core-1_0.html">OpenID Connect Core 1.0 incorporating errata set 1</a><br>[6] <a href="https://developers.google.com/identity/openid-connect/openid-connect#java">OpenID Connect - Google</a><br>[7] <a href="https://help.aliyun.com/document_detail/174224.html?utm_content=g_1000230851&spm=5176.20966629.toubu.3.f2991ddcpxxvD1#CWelL">SAML</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;单点登录（SSO，Single Sign On）是一种身份验证解决方案，可让用户通过一次性用户身份验证登录多个相互信任的应用程序和网站。&lt;/</summary>
      
    
    
    
    <category term="安全建设思路" scheme="https://kylinlingh.github.io/categories/%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE%E6%80%9D%E8%B7%AF/"/>
    
    
    <category term="SSO" scheme="https://kylinlingh.github.io/tags/SSO/"/>
    
    <category term="账号安全" scheme="https://kylinlingh.github.io/tags/%E8%B4%A6%E5%8F%B7%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>企业DevSecOps流程建设之工具篇</title>
    <link href="https://kylinlingh.github.io/2022/06/21/%E4%BC%81%E4%B8%9ADevSecOps%E6%B5%81%E7%A8%8B%E5%BB%BA%E8%AE%BE%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/"/>
    <id>https://kylinlingh.github.io/2022/06/21/%E4%BC%81%E4%B8%9ADevSecOps%E6%B5%81%E7%A8%8B%E5%BB%BA%E8%AE%BE%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/</id>
    <published>2022-06-21T00:49:05.000Z</published>
    <updated>2023-01-29T07:48:34.199Z</updated>
    
    <content type="html"><![CDATA[<p>任何一个安全项目或体系的建设始终围绕着三个核心点来进行：组织，流程，工具：</p><ul><li>组织：确立项目目标和建设实施团队</li><li>流程：建立制度，明确各方责任</li><li>工具：支撑流程的运转</li></ul><p>本文着眼于DevSecOps流程建设中所使用的工具，暂时先不讨论其他两个点。</p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在讲究小步快跑和快速迭代的互联网企业里，效率的优先级要比质量高，在发展中解决质量问题是大家的共识。这种观点在书本《Google系统架构解密》<a href="#refer-anchor"><sup>[8]</sup></a>中是这样评价的：</p><blockquote><p>区分初始速度和持续速度是很重要的。在项目初期选择不考虑安全性、可靠性和可维护性等关键需求，确实会提高项目早期的速度。然而经验表明，这样做通常会在项目中后期显著地拖慢进度。为了适应涌现特性的需求而重构设计的后期成本可能非常高。此外，为解决安全和可靠性风险而进行侵入性的后期更改本身可能会带来更多的安全和可靠性风险。</p></blockquote><p>结合我在互联网企业里的项目开发经历来看，在没有建设好安全文化和流程（换句话说，不重视安全）的互联网公司里，传统的SDL流程还是稍显笨重。如果真的强求每个项目都在立项之处就从安全威胁建模做起，光是安全团队的规模就很庞大；另一方面，追求项目快速迭代的团队也不希望被团队外的安全人员卡点。目前来看，应用安全建设里最可靠的方法还是建设好DevOps的工具链，在工具链里融入可以高度自动化的安全测试工具，在项目的编码，集成，发布和运行阶段都进行安全测试并提供足够的安全故障自助处理工具让开发人员将项目的安全水位提升到及格线之上。</p><h1 id="DevSecOps流程建设"><a href="#DevSecOps流程建设" class="headerlink" title="DevSecOps流程建设"></a>DevSecOps流程建设</h1><p>建设DevSecOps流程需要一个体系化的建设思维，现在随便谷歌一下也能找到一大堆解决各个单点问题的开源工具，但我觉得要真的做好DevSecOps流程建设，需要把握几个关键点：</p><ul><li>全局把握安全建设的重点方向和节奏，了解清楚各个单点问题的轻重缓急，先做哪个后做哪个其实很重要，毕竟企业愿意往安全方向投入的资源本来就很少，如何用很少的资源去支撑整个安全团队的持续发展也是一个需要思考的问题。</li><li>如何将各个单点工具串联起来并自动化运营，也就是所谓的安全编排，毕竟工具越多，告警越多，需要投入的安全人力就越多。如果没有自动化运营的能力，搞到最后就会出现部署一大堆东西但是没人管的局面。</li></ul><p>首先思考代码的漏洞来自何方，我们才能知道究竟要解决DevOps中的哪些安全问题：</p><ul><li>编码过程引入的漏洞<br>典型的例子是后端程序在接收到参数时直接拼接成sql语句执行，很容易就会遭到sql攻击</li><li>代码中引入了开源组件中的漏洞<br>如fastjson，log4j等应用非常广泛的第三方组件在你使用的时候是安全的，但保不准哪一天就会爆出致命漏洞</li><li>代码的运行环境配置不正确<br>没有遵照代码运行环境（包括容器，云上和云下的服务器）的安全基线来配置启动参数</li><li>供应链被投毒<br>简而言之，就是第三方供应商提供的软件/硬件里包含了漏洞，譬如dockerhub上的投毒镜像</li></ul><h2 id="工具建设"><a href="#工具建设" class="headerlink" title="工具建设"></a>工具建设</h2><p>首先看一下DevSecOps流程中每个环节要用到的工具，如下图所示：<br><img src="https://www.softwaretestinghelp.com/wp-content/qa/uploads/2020/12/Application-Sec.png"><br>图中对应的四个阶段分别是：开发，集成（代码编译，生成镜像），发布（推送到运行环境）和运行。本章节会先介绍上图中经常出现的SAST，DAST，IAST这三个极其容易让人混淆的概念，然后再比较IAST与RASP的关系，最后介绍SCA，至于代码质量管控，威胁建模和镜像扫描则不在本文中介绍。</p><h3 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h3><p>AST类工具是测试工具，并不是漏洞挖掘工具。</p><ul><li><p>SAST（Static Application Security Testing，静态应用安全测试）：SAST是白盒测试（<strong>可以看到应用的所有源码</strong>）的一种。简单来说，就是<strong>在应用编译前进行源码扫描</strong>，特点是误报率高。最好的实现方式是开发IDE的插件，以便开发人员在编码的时候就可以直接检测代码；另外，也可以把安全编码规范融入到IDE的插件中（例如<a href="https://blog.csdn.net/Monsterof/article/details/108239250">Alibaba Java Coding Guidelines</a>），这样的做法要比对开发人员进行线下编码规范培训的效果好。</p></li><li><p>DAST(Dynamic Application Security Testing，动态应用安全测试)：DAST是黑盒测试（<strong>看不到应用的源码</strong>）的一种，简单来说，就是先把应用运行起来，然后不断地输入各种测试案例，通过观察生成的输出来判断是否有漏洞，常见的web扫描器就是DAST的一种工具。</p></li><li><p>IAST（Interactive Application Security Testing，交互式应用安全测试）：IAST是灰盒测试的一种。（<strong>灰盒测试就是你能定位到代码问题的精确位置，譬如哪个源码文件的哪一行，但是你并不知道是什么原因导致的；白盒测试就是打开整个项目的源码，通读代码后找出导致这个问题的原因；而黑盒测试就是在项目运行的时候跑了一大堆测试后看到输出结果不正常，至于错在哪里，怎么错的一概不知</strong>）通过部署在服务器上的agent收集应用运行时的各种数据（接收到的请求，执行的函数，传递的参数等）来判断是否有漏洞（参考下面的洞态 IAST），如果想要做得更加精确，可以将业务请求放到扫描器上重放（参考下面的Baidu openrast-iast）。</p></li></ul><p><strong>三者之间的关系</strong><br>从下图中的左边部份可以看到SAST与DAST演化出了IAST，而WAF和IDS/IPS技术则逐渐演化出了RASP（在下一小节会介绍）。</p><p><img src="https://hexo-pic-1300331708.cos.ap-guangzhou.myqcloud.com/2022-12-29-13-04-59.png" alt="三者之间的关系"></p><p>下面通过两个IAST的开源产品来分析一下它的工作原理。</p><p><a href="https://doc.dongtai.io/docs/introduction/iast">洞态IAST</a>，它的产品文档里的原话是这样描述的：</p><blockquote><p>IAST 相当于 DAST 和 SAST 的组合，是一种相互关联的运行时安全检测技术。它通过使用部署在 Web 应用程序上的 Agent 来监控运行时发送的流量并分析流量流以实时识别安全漏洞。<br><img src="https://hexo-pic-1300331708.cos.ap-guangzhou.myqcloud.com/2022-12-29-18-23-49.png" alt="三者的区别"></p></blockquote><p>其实我觉得IAST算不上是DAST和SAST的组合，这是三个不同功能的产品，并不是说有了IAST就可以替代SAST和DAST了。结合上图再重新看我对IAST的概念解析就一目了然了。</p><p>再看其架构图<a href="#refer-anchor"><sup>[8]</sup></a>，原文如下：</p><blockquote><p>首先，在服务器上安装 IAST Agent。当 IAST 启动，用户访问 Agent 服务后，Agent 便开始采集数据，并与 OpenAPI 服务通信，进行上报数据和 Hook 规则的拉取。OpenAPI 将数据存储到数据库中，包括 MySQL 和 Redis。<br>然后，Agent 对 Engine 发送通知，Engine 便会来消费数据库中的数据，并在分析(<a href="https://doc.dongtai.io/docs/introduction/architecture#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86">漏洞分析原理</a>)完毕后将漏洞信息回写到数据库中。<br>最后，用户通过 WebAPI 查看数据库中漏洞的数据信息。<br><img src="https://hexo-pic-1300331708.cos.ap-guangzhou.myqcloud.com/2022-12-29-18-20-29.png" alt="洞态IAST架构"></p></blockquote><p><a href="https://rasp.baidu.com/doc/hacking/architect/iast.html">百度 openrasp-iast </a>，关于系统架构的原话：</p><blockquote><p>IAST（交互式扫描）技术是一种实时动态交互的漏洞检测技术，通过在服务端部署agent程序，收集、监控Web应用程序运行时函数执行、数据传输，并与扫描器端进行实时交互，高效、准确的识别安全缺陷及漏洞。目前OpenRASP项目已实现相当于IAST agent端的OpenRASP agent，在此基础上引入一个扫描端，即可实现一个完整的IAST扫描工具。<br><img src="https://hexo-pic-1300331708.cos.ap-guangzhou.myqcloud.com/2022-12-29-19-59-19.png"></p></blockquote><p>从架构上可以看到它跟洞态 IAST 的不同之处是引入了一个扫描器来对每一个正常的业务请求进行流量重放。</p><h3 id="RASP"><a href="#RASP" class="headerlink" title="RASP"></a>RASP</h3><p>RASP（Runtime Application Self-Protection，运行时应用程序自我保护），其运行原理如下图所示：<br><img src="https://hexo-pic-1300331708.cos.ap-guangzhou.myqcloud.com/2022-12-29-10-25-52.png" alt="RASP技术原理"></p><ol><li><p><strong>收集数据</strong>：在运行APP的服务器上需要部署一个agent，这个agent会将防护功能”<strong>注入</strong>“到应用程序中，与应用程序融为一体。这里所谓的“注入”在不同的开发语言中会有不同的实现，以java举例，它的实现方式是通过Instrumentation接口（java.lang.instrument）编写一个agent，在 agent 中加入 hook 点，当程序运行流程到了 hook 点时，将检测流程插入到字节码文件中，统一进入JVM中执行(<a href="https://rasp.baidu.com/doc/hacking/architect/java.html">更底层的实现原理参考这里</a>)。<strong>既可以在APP运行前就注入，也可以在APP运行时注入</strong>，尤其是运行时注入的能力提供了在APP不重启的情况下进行漏洞热修复的功能。实现原理如下图所示：<br><img src="https://hexo-pic-1300331708.cos.ap-guangzhou.myqcloud.com/2022-12-29-12-51-14.png"></p></li><li><p><strong>阻断执行</strong>，agent还可以根据请求的参数和应用运行时的上下文（堆栈信息）来判断是否需要阻断该请求。RASP一般都会拿来与WAF（Web Application Firewall）进行比较，因为WAF也是在APP处理请求前先过滤掉请求，<strong>但WAF只能通过检测流量的特征，而不能获取到应用运行时的上下文</strong>，所以会造成很多误报。同时WAF严重依赖于恶意流量的特征库，只要特征库更新不及时就很容易被绕过。举例来说，log4j漏洞在刚爆发时，短时间内就出现了很多poc，WAF是很难及时将全部poc都同步到规则库中；并且攻击者可以通过流量混淆工具来隐藏恶意poc，导致WAF出现误报和漏报。但是RASP就可以很好地处理这个难题，因为只要agent检测到log4j漏洞使用的JNDI的框架，就可以结合上下文信息来判断是否需要停止应用的业务响应流程，从而拦截恶意请求，如下图所示：<br><img src="https://hexo-pic-1300331708.cos.ap-guangzhou.myqcloud.com/202212291243917.png"></p></li></ol><p>RASP的开源产品有<a href="https://rasp.baidu.com/">百度 openRASP</a>，上面提到的百度 openrasp-iast 就是在此产品的基础上添加了一个扫描器而成，由此可见 IAST 与 RASP 的紧密联系。</p><p>Q：是否有了RASP就完全不需要WAF呢？<br>A：我认为二者是互相补充，而不是替代关系。RASP的确可以比WAF看到更多的信息（如下图所示），但并不是所有的应用都可以通过RASP来做保护，目前RASP最广泛的应用场景还是在java语言开发的APP上；另外一个问题时RASP对APP造成的性能影响你又是否能接受呢；并且万一RASP引入了新的故障点，谁来负责处理也是个问题。<br><img src="https://hexo-pic-1300331708.cos.ap-guangzhou.myqcloud.com/2022-12-29-12-56-11.png"></p><p>额外提一下，我认为RASP在一种特殊场景下会比较有用，那就是保护那些已经运行很久的遗留项目或者是没有源代码的第三方项目，并且这些项目对性能的要求并不高。</p><hr><p>最后展示一下这四个工具在DevSecOps流程中发挥作用的阶段，如下图所示<a href="#refer-anchor"><sup>[1]</sup></a>，其中圆点的实心比例表示工具的自动化程度：<br><img src="https://hexo-pic-1300331708.cos.ap-guangzhou.myqcloud.com/2022-12-28-18-20-21.png" alt="DevSecOps 安全工具在不同阶段的自动化程度"></p><p>至此，已经介绍完了DevSecOps里常用的几个漏洞测试工具，下面继续分析剩余的其他工具。</p><h3 id="SCA"><a href="#SCA" class="headerlink" title="SCA"></a>SCA</h3><p>SCA（Software component analysis，软件成分分析）：如字面意思，此工具就是用来分析软件成分的，何为软件成分？那就先引入一个新的名词：<strong>SBOM<a href="#refer-anchor"><sup>[1]</sup></a>（Software Bill of Materials，软件物料清单）</strong> 其概念来自于制造业，譬如汽车制造商为每辆汽车维护的BOM就列出了原始设备制造商和第三方供应商的零件清单，用于在发现零件缺陷的时候可以根据批次信息来跟踪处理。<strong>而在软件上，BOM描述的是软件包依赖树的一系列元数据</strong>，包括组件名称、版本号、许可证、版权等多项关键信息。目的是为了发现潜在的<strong>安全问题</strong>（软件漏洞）和<strong>许可证问题</strong>（假如你引用的开源软件用的是GPL许可证，那么你开发的软件也必须公开全部源代码，<a href="https://xie.infoq.cn/article/e3be19b16c33494a173458c4c">可以参考这个案例</a>）。</p><p>SBOM的两大作用：</p><ol><li>维护了一份软件的资产清单，在处理组件漏洞的时候可以快速定位到受影响的软件资产，避免了两眼一抹黑，连自家有哪些软件受漏洞影响都不知道的情况。</li><li>在DevSecOps的流程中嵌入SCA（软件成分分析）工具，通过对生成的SBOM进行漏洞和许可证匹配，在软件上线之前就检测出安全问题和许可证问题，可以减少上线后才发现问题而带来的很多麻烦。</li></ol><p>一份完整的SBOM生产流程如下图所示<a href="#refer-anchor"><sup>[1]</sup></a>，注意SBOM需要跟随软件的迭代而更新，因此需要使用自动化工具来创建，而SCA提供了这样的能力。</p><p><img src="https://hexo-pic-1300331708.cos.ap-guangzhou.myqcloud.com/2022-12-28-18-34-02.png" alt="SBOM生产流程"></p><p>既然已经有了SBOM，那就剩下用漏洞库去匹配这个清单，找出其中有漏洞的组件。公开的漏洞库包括有：NVD/CNVD/CNNVD，但这些国家级漏洞库收录的漏洞数量非常多，并且很多都是很陈旧的，越庞大的漏洞库虽然能带来越高的漏洞发现率，但也意味着匹配的时间越长。并且一个项目是否通过检查出来的漏洞数量来衡量其安全水位呢，也值得你去思考。我更推荐<a href="https://security.snyk.io/">snyk vulnerability db</a>，漏洞的数据格式一致，不需要用多个不同的html解析模板，并且数据的速度也够快，但使用爬虫去高频爬取这个漏洞库可能会存在法律风险。</p><p>下面介绍一下SCA里的一个知名开源产品：<a href="https://jeremylong.github.io/DependencyCheck/">OWASP Dependency-Check</a>，它的工作原理如下：</p><ol><li>收集项目依赖信息：JarAnalyzer模块从Java项目的 Manifest, pom.xml 和 JAR 文件里的包名收集足够的项目依赖信息。</li><li>分析并索引漏洞库：将NVD的漏洞库解析出来并通过Lucene索引存储</li><li>匹配依赖与漏洞库：CPEAnalyzer模块会匹配项目中的每个依赖与漏洞库，最后将所有命中的漏洞库生成一个报告，报告内容如下<a href="#refer-anchor"><sup>[12]</sup></a>：</li></ol><p><img src="https://hexo-pic-1300331708.cos.ap-guangzhou.myqcloud.com/2023-01-03-16-53-00.png" alt="漏洞报告"></p><p>注意，OWASP Dependency-Check 并没有收集详细的SBOM，也没有致力于解决许可证风险，并不是SCA的完全体。而另一个开源项目 <a href="https://github.com/murphysecurity/murphysec/blob/master/README_ZH.md">墨菲安全 - murphysec</a> 则收集了SBOM并列举了许可证风险，可以参考一下。</p><h3 id="ASOC"><a href="#ASOC" class="headerlink" title="ASOC"></a>ASOC</h3><p>大家看到安全编排这个词时可能先想起的是 SOAR（Security Orchestration, Automation and Response，安全编排自动化与响应），但我在此文里强调的更多是应用安全，SOAR的概念要比 ASOC（Application Security Orchestration and Correlation，应用安全编排和关联）庞大且复杂。为了始终聚焦 DevSecOps ，我在此采用的是 ASOC 这个概念， <a href="https://www.synopsys.com/glossary/what-is-application-security-orchestration-and-correlation.html">synopsys</a> 是这样来定义这个概念的：</p><blockquote><p>应用安全编排和关联(Application Security Orchestration and Correlation,ASOC)是一种<strong>通过自动化的工作流</strong>来帮助简化漏洞测试和修复过程的应用安全解决方案，ASOC从各种应用安全工具(如SAST，DAST和IAST)<strong>收集数据</strong>并将他们合并到一个数据库中，然后<strong>通过关联分析这些数据来确定漏洞修复工作的优先级</strong>，最终使安全团队能够以知情且高效的方式来精简应用安全的运营工作。</p></blockquote><p>从定义中就可以看到关键词：工作流，大家在日常工作中通过OA里发起的各种审批流程就是一个工作流：发起申请 -&gt; 工作流创建并开始；各级人员审批 -&gt; 工作流执行；流程归档 -&gt; 工作流结束。因此 <strong>ASOC 工具的关键就是创建工作流，在不同的人员中自动化流转漏洞处理工单</strong>。</p><p>对应的商业软件有 <a href="https://www.synopsys.com/software-integrity/code-dx.html">synopsys Code Dx</a> ，但并没从中找到什么参考价值。反而可以从 <a href="https://juejin.cn/post/6844904167463485453">工作流引擎原理-打造一款适合自己的工作流引擎</a> 这篇文章里找到工作流的实现方法，下图展示了我们自己设计的漏洞工单工作流，在漏洞的修复流程中主要关联了开发人员和安全人员，在一个漏洞被修复的过程中，整个工单经过的流程如下所示：<br><img src="https://hexo-pic-1300331708.cos.ap-guangzhou.myqcloud.com/2023-01-04-18-00-06.png" alt="漏洞工作流"></p><p>我们所有的漏洞测试系统都关联到这个工作流中，当某个系统检测出了漏洞之后会自动创建工作流的实例并自动在企业微信上通知相关人员修复漏洞，当工单负责人修复好了漏洞之后，在我们的安全平台上点击“确定修复”之后，系统就会自动测试该漏洞是否真的已经被修复，只要复测通过就自动结束该流程，关闭工单。从整个流程可以看到，基本不需要安全人员介入，极大地节省了人力。</p><h2 id="产品与工具矩阵图"><a href="#产品与工具矩阵图" class="headerlink" title="产品与工具矩阵图"></a>产品与工具矩阵图</h2><p>下面罗列一下各种工具对应的开源和商业产品，有兴趣的可以挑出几个来分析。</p><table><thead><tr><th align="left"></th><th align="left">SAST</th><th align="left">DAST</th><th align="left">IAST</th><th align="left">RASP</th><th align="left">SCA</th></tr></thead><tbody><tr><td align="left">开源</td><td align="left">NodeJsScan, SonarQube,</td><td align="left">OWASP ZAP</td><td align="left">洞态 IAST , baidu openrasp-iast, Shadowd</td><td align="left">OWASP AppSensor, 百度 openRASP</td><td align="left">墨菲安全, OWASP Dependency-Check</td></tr><tr><td align="left">商业</td><td align="left">SonarQube, Synk, CheckMarx, Bandit, GitLeaks, Synopsys</td><td align="left">Acunetix, Synopsys, AppSpider, Acunetix, Burp Suite, Checkmarx</td><td align="left">灵脉IAST</td><td align="left">云鲨RASP, Contrast Security, Waratek</td><td align="left">Blackduck, DepScan, HCL AppScan, Synk, Sonatype, Synopsys</td></tr></tbody></table><h1 id="我的建设思路"><a href="#我的建设思路" class="headerlink" title="我的建设思路"></a>我的建设思路</h1><p>结合我司的安全建设历程和效果，我认为整个工具链可以按照以下顺序来建设：</p><ol><li>SCA：软件成分分析应该摆在第一位，原因有以下几点：<ul><li>现在爆发严重漏洞的次数有越来越多的趋势，并且每个都很致命。在我司建设SCA之前，遇到这种情况就只能发整改表，依赖于业务自查；一方面会导致沟通成本非常高，另一方面，有些项目在交接过很多次之后就被人遗忘了，无法做到一个全局的掌握。将SCA嵌入到DevOps的流程中，在项目上线前先进行软件成分分析，从而掌握线上生产项目的资产表。如果不这样做，而是对公司的整个代码仓库进行软件成分分析，这样是没有意义的，因为我们并不关注那些没有在生产环境运行的项目代码。</li><li>SCA可以做到高度自动化，如果没有漏洞编排工具，那么将SCA系统与公司的IM软件（如企业微信，钉钉等）和告警系统打通也能实现一定程度上的漏洞编排功能。SCA并不仅仅是漏洞应急工具，更应该是一个日常运行的工具，毕竟随时会有开发人员无意间使用含有漏洞的第三方库。</li></ul></li><li>ASOC：安全编排工具可以与SCA进行同步开发，因为ASOC可以赋予SCA高度自动化的能力，并且在SCA上线前优化用户体验的时候也需要同步调整ASOC。有了ASOC之后，所有的安全服务都可以编排出来并按照流程自动化运行，彻底走出了手工excel运营的阶段。</li><li>制品扫描：曾经发生过的 XcodeGhost 风波是攻击者在非官方的 Xcode 软件中植入了后门从而将恶意代码植入到开发者生成的iOS应用程序中，属于供应链攻击的一种。所以即使代码经过了SCA的测试，最终生成的制品仍然可能是不安全的。最好的办法就是对生成的二进制程序或docker镜像再进行一次扫描，可以检查出这些SCA无法发现的问题：安全配置问题，编译选项检查，敏感信息检查等。</li><li>漏洞扫描器：安全团队一般都用来做日常的定期巡检，其实也可以对业务/SRE团队开放特定的扫描能力，用于在业务上线前进行web安全测试。</li><li>SAST：我之前用过SonarQube来做静态代码扫描，但代码质量这个东西不好推广，因为每个项目都能检出一大堆问题，并且误报还不少，所以在试用过之后也搁置了。</li><li>RASP：正如前文所说，RASP比较难推广，越是重要的公司级业务就越追求性能表现，现在为了加强安全而消耗掉部份性能，对业务来说是很难接受的；另一方面，万一RASP引入了新的故障点，这个也会严重破坏安全与业务人员和SRE之间的团队关系。但是RASP的确带来了很多新的优势，尤其是可以防那些未披露的漏洞，<strong>该技术可以保持长久的关注</strong>。</li><li>Fuzzing（模糊测试）：这里引入的模糊测试在常规的DevOps流程中并不常见，在此做一下简单介绍：模糊测试是通过自动生成随机的数据值或文件去测试API，用于解决数据验证中的问题，并查看当传递了错误的值时系统会发生什么情况。安全研究人员通常使用Fuzzing技术来查找代码中的漏洞，但Fuzzing存在一个大的问题是在测试中可能使得系统崩溃，并且并不总是能提供很明确的错误反馈，需要人员投入大量的时间进行排查，因此该技术在自动化测试的流程中并不常见。</li></ol><div id="refer-anchor"></div><h1 id="本文引用"><a href="#本文引用" class="headerlink" title="本文引用"></a>本文引用</h1><p>[1] <a href="https://www.dsocon.cn/2021/#/down">软件供应链安全白皮书2021 by 悬镜</a><br>[2] <a href="https://www.jrasp.com/guide/">RASP安全技术</a><br>[3] <a href="https://tech.meituan.com/2019/11/07/java-dynamic-debugging-technology.html">Java 动态调试技术原理及实践</a><br>[4] <a href="https://www.anquanke.com/post/id/263539">Apache Log4j2，RASP防御优势及原理</a><br>[5] <a href="https://www.softwaretestinghelp.com/differences-between-sast-dast-iast-and-rasp/">Differences Between SAST, DAST, IAST, And RASP</a><br>[6] <a href="https://www.51cto.com/article/717663.html">How Instrumentation-based IAST and RASP Revolutionize Vulnerability Assessment for Application</a><br>[7] <a href="https://www.synopsys.com/glossary/what-is-application-security-orchestration-and-correlation.html">Application Security Orchestration and Correlation</a><br>[8] <a href="https://jishuin.proginn.com/p/763bfbd710bd">重磅推荐: 全球唯一开源的 IAST 自动化漏洞检测工具</a><br>[9] 《Google系统架构解密：构建安全可靠的系统》 希瑟·阿德金斯, 贝齐·拜尔, 保罗·布兰肯希普, 彼得·莱万多夫斯基, 阿那·奥普雷亚, 亚当·斯塔布菲尔德 著；周雨阳 刘志颖 译<br>[10]《敏捷应用程序安全》 Laura Bell, Michael Brunton-Spall, Rich Smith, Jim Bird 著；杨宏焱， 刘恒屹 译<br>[11]《DevSecOps敏捷安全》 子芽 著<br>[12] <a href="https://blog.xujiuming.com/ming/61a3df4c.html">owasp扫描依赖漏洞笔记</a><br>[13] <a href="https://juejin.cn/post/6844904167463485453">工作流引擎原理-打造一款适合自己的工作流引擎</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;任何一个安全项目或体系的建设始终围绕着三个核心点来进行：组织，流程，工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组织：确立项目目标和建设实施团队&lt;/li&gt;
&lt;li&gt;流程：建立制度，明确各方责任&lt;/li&gt;
&lt;li&gt;工具：支撑流程的运转&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文着眼于DevSec</summary>
      
    
    
    
    <category term="安全建设思路" scheme="https://kylinlingh.github.io/categories/%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE%E6%80%9D%E8%B7%AF/"/>
    
    
    <category term="DevSecOps" scheme="https://kylinlingh.github.io/tags/DevSecOps/"/>
    
    <category term="依赖检测" scheme="https://kylinlingh.github.io/tags/%E4%BE%9D%E8%B5%96%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
</feed>
